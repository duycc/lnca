# 05. 服务器程序规划

## 一、信号高级认识范例
`ps -eo pid,ppid,sid,tty,pgrp,comm,stat,cmd | grep -E 'bash|PID|nginx'`

**用kill 发送 USR1信号给运行中的进程**
（1）执行信号处理函数被卡住了10秒，这个时候因为流程回不到`main()`，所以main中的语句无法得到执行；

（2）在触发SIGUSR1信号并因此sleep了10秒种期间，就算你多次触发SIGUSR1信号，也不会重新执行SIGUSR1信号对应的信号处理函数,而是会等待上一个`SIGUSR1`信号处理函数执行完毕才第二次执行SIGUSR1信号处理函数；换句话说：在信号处理函数被调用时，==操作系统建立的新信号屏蔽字（`sigprocmask()`）自动包括了正在被递送的信号。保证了在处理一个给定信号的时候，如果这个信号再次发生，那么它会阻塞到对前一个信号处理结束为止==

（3）不管你发送了多少次`kill -usr1`信号，在该信号处理函数执行期间，后续所有的`SIGUSR1`信号统统==被归结为一次==。比如当前正在执行SIGUSR1信号的处理程序但没有执行完毕，这个时候，你又发送来了5次SIGUSR1信号，那么当SIGUSR1信号处理程序执行完毕（解除阻塞），SIGUSR1信号的处理程序也只会被调用一次（而不会分别调用5次SIGUSR1信号的处理程序）

`kill -usr1,kill -usr2`
（1）执行usr1信号处理程序，但是没执行完时，是可以继续进入到usr2信号处理程序里边去执行的，这个时候，
相当于usr2信号处理程序没执行完毕,usr1信号处理程序也没执行完毕；此时再发送usr1和usr2都不会有任何响应；
（2）既然是在执行usr1信号处理程序执行的时候来了usr2信号，导致又去执行了usr2信号处理程序，这就意味着，只有usr2信号处理程序执行完毕，才会返回到usr1信号处理程序，只有usr1信号处理程序执行完毕了，才会最终返回到main函数主流程中去继续执行

## 二、服务器架构
### 2.1 目录结构规划
**特别注意：**不管是目录还是文件，文件名中一律不要带空格，一律不要用中文，最好的方式：字母，数字，下划线；

```
主目录名nginx

a)_include目录：专门存放各种头文件； 如果分散:#include "sfaf/sdafas/safd.h"

b)app目录：放主应用程序.c(main()函数所在的文件)以及一些比较核心的文件；
	b.1)link_obj：临时目录：会存放临时的.o文件，这个目录不手工创建，后续用makefile脚本来创建
	b.2)dep：临时目录，会存放临时的.d开头的依赖文件，依赖文件能够告知系统哪些相关的文件发生变化，需要重新编译，后续用makefile脚本来创建
	b.3)nginx.c：主文件，main()入口函数就放到这里；
	b.4)ngx_conf.c  ，普通的源码文件，跟主文件关系密切，又不值得单独放在一个目录；
	
c)misc目录：专门存放各种杂合性的不好归类的1到多个.c文件；暂时为空

d)net目录：专门存放和网络处理相关的1到多个.c文件，暂时为空

e)proc目录：专门存放和进程处理有关的1到多个.c文件，暂时为空

f)signal目录：专门用于存放和信号处理有关的1到多个.c文件；ngx_signal.c
```

### 2.2 编译工具make的使用
每个.c生成一个.o，多个.c生成多个.o，最终这些.o被链接到一起，生成一个可执行文件
`gcc -o nginx ng1.c`
`gcc -o nginx ng1.c ng2.c`

a) 借助 make 的命令来编译：能够编译，链接，最终生成可执行文件，大型项目一般都用make来管理

b) make命令的工作原理，就去当前目录读取一个叫做 Makefile 的文件（文本文件），根据这个makefile文件里的规则把源代码编译成可执行文件

==实际上makefile文件就是一个我们编译工程要用到的各种源文件等等的一个依赖关系描述==

c) makefile文件：文本文件，utf8编码格式，没有扩展名，一般放在根目录下[也会根据需要放在子目录]

**规划一下makefile文件的编写**
a)nginx根目录下我会放三个文件：
a.1) `Makefile`：编译项目的入口脚本，编译项目从这里开始，总体控制
a.2）`config.mk`：这是个配置脚本，被makefile文件包含；单独分离出来是为了应付一些可变的东西,所以，一般变动的东西都往这里搞；
a.3) `common.mk`：是最重要最核心的编译脚本，定义 Makefile 的编译规则，依赖规则等，通用性很强的一个脚本，并且各个子目录中都用到这个脚本来实现对应子目录的`.c`文件的编译

b)每个子目录下（app,signal)都有一个叫做 makefile 的文件，每个这个makefile文件，都会包含根目录下的common.mk，从而实现自己这个子目录下的.c文件的编译，现在的makefile不支持目录中套子目录，除非大家自己修改

### 2.3 Makefile脚本用法
a) 编译项目，生成可执行文件
`make`
`make clean`

### 2.4 Makefile脚本具体实现
```makefile

#.PHONY:all clean 

ifeq ($(DEBUG),true)
#-g是生成调试信息。GNU调试器可以利用该信息
CC = gcc -g
VERSION = debug
else
CC = gcc
VERSION = release
endif

SRCS = $(wildcard *.c)

OBJS = $(SRCS:.c=.o)

DEPS = $(SRCS:.c=.d)

BIN := $(addprefix $(BUILD_ROOT)/,$(BIN))

LINK_OBJ_DIR = $(BUILD_ROOT)/app/link_obj
DEP_DIR = $(BUILD_ROOT)/app/dep

#-p是递归创建目录，没有就创建，有就不需要创建了
$(shell mkdir -p $(LINK_OBJ_DIR))
$(shell mkdir -p $(DEP_DIR))


# := 在解析阶段直接赋值常量字符串【立即展开】，而 = 在运行阶段，实际使用变量时再进行求值【延迟展开】

OBJS := $(addprefix $(LINK_OBJ_DIR)/,$(OBJS))
DEPS := $(addprefix $(DEP_DIR)/,$(DEPS))


LINK_OBJ = $(wildcard $(LINK_OBJ_DIR)/*.o)
#因为构建依赖关系时app目录下这个.o文件还没构建出来，所以LINK_OBJ是缺少这个.o的，我们 要把这个.o文件加进来
LINK_OBJ += $(OBJS)

all:$(DEPS) $(OBJS) $(BIN)

#这里是诸多.d文件被包含进来，每个.d文件里都记录着一个.o文件所依赖哪些.c和.h文件。内容诸如 nginx.o: nginx.c ngx_func.h
#我们做这个的最终目的说白了是，即便.h被修改了，也要让make重新编译我们的工程，否则，你修改了.h，make不会重新编译，那不行的
#有必要先判断这些文件是否存在，不然make可能会报一些.d文件找不到
ifneq ("$(wildcard $(DEPS))","")   #如果不为空,$(wildcard)是函数【获取匹配模式文件名】，这里 用于比较是否为""
include $(DEPS)  
endif

#----------------------------------------------------------------1begin------------------
#$(BIN):$(OBJS)
$(BIN):$(LINK_OBJ)
	@echo "------------------------build $(VERSION) mode--------------------------------!!!"

#一些变量：$@：目标，     $^：所有目标依赖
# gcc -o 是生成可执行文件
	$(CC) -o $@ $^

#----------------------------------------------------------------1end-------------------


#----------------------------------------------------------------2begin-----------------
#%.o:%.c
$(LINK_OBJ_DIR)/%.o:%.c
# gcc -c是生成.o目标文件   -I可以指定头文件的路径
#如下不排除有其他字符串，所以从其中专门把.c过滤出来 
#$(CC) -o $@ -c $^
	$(CC) -I$(INCLUDE_PATH) -o $@ -c $(filter %.c,$^)
#----------------------------------------------------------------2end-------------------



#----------------------------------------------------------------3begin-----------------
#我们现在希望当修改一个.h时，也能够让make自动重新编译我们的项目，所以，我们需要指明让.o依赖于.h文件
#那一个.o依赖于哪些.h文件，我们可以用“gcc -MM c程序文件名” 来获得这些依赖信息并重定向保存到.d文件中
#.d文件中的内容可能形如：nginx.o: nginx.c ngx_func.h
#%.d:%.c
$(DEP_DIR)/%.d:%.c
#gcc -MM $^ > $@
#.d文件中的内容形如：nginx.o: nginx.c ngx_func.h ../signal/ngx_signal.h，但现在的问题是我们的.o文件已经放到了专门的目录
# 所以我们要正确指明.o文件路径这样，对应的.h,.c修改后，make时才能发现，这里需要用到sed文本处理工具和一些正则表达式语法，不必深究
#gcc -MM $^ | sed 's,\(.*\)\.o[ :]*,$(LINK_OBJ_DIR)/\1.o:,g' > $@
#echo 中 -n表示后续追加不换行
	echo -n $(LINK_OBJ_DIR)/ > $@
#	gcc -MM $^ | sed 's/^/$(LINK_OBJ_DIR)&/g' > $@
#  >>表示追加
	gcc -I$(INCLUDE_PATH) -MM $^ >> $@

#上行处理后，.d文件中内容应该就如：/mnt/hgfs/linux/nginx/app/link_obj/nginx.o: nginx.c ngx_func.h ../signal/ngx_signal.h

#----------------------------------------------------------------4begin-----------------



#----------------------------------------------------------------nbegin-----------------
#clean:			
#rm 的-f参数是不提示强制删除
#可能gcc会产生.gch这个优化编译速度文件
#	rm -f $(BIN) $(OBJS) $(DEPS) *.gch
#----------------------------------------------------------------nend------------------
```