# 04. fork函数，守护进程

## 一、fork()函数详解

### 1.1 fork()函数简单认识
作用：创建进程
进程：一个可执行程序，执行起来就是一个进程，再执行起来一次，它就又是一个进程（多个进程可以共享同一个可执行文件），进程定义为程序执行的一个实例；

在一个进程（程序）中，可以用`fork()`创建一个子进程，当该子进程创建时，它从`fork()`指令的下一条(或者说从`fork()`的返回处)开始执行与==父进程相同==的代码；

a)说白了：fork()函数产生了一个和当前进程完全一样的新进程，并和当前进程一样从fork()函数里返回；原来一条执行通路（父进程），现在变成两条（父进程+子进程）

**（1.1）fork()函数简单范例**
`ps -eo pid,ppid,sid,tty,pgrp,comm,stat | grep -E 'bash|PID|03_fork'`
fork()之后，是父进程fork()之后的代码先执行还是子进程fork()之后的代码先执行是不一定的；这个跟内核调度算法有关；
kill子进程，观察父进程收到什么信号：`SIGCHLD`信号 ，子进程变成了僵尸进程Z（系统没有回收其资源）

**（1.2）僵尸进程的产生、解决，SIGCHLD**
僵尸进程的产生：在Unix系统中，一个子进程结束了，但是他的父进程还活着，但该父进程没有调用`(wait/waitpid)`函数来进行额外的处置，那么这个子进程就会变成一个僵尸进程；

僵尸进程：已经被终止，不干活了，但是依旧没有被内核丢弃掉，因为内核认为父进程可能还需要该子进程的一些信息；==作为开发者，坚决不允许僵尸进程的存在==；

**如何处理掉僵尸进程：**
a)重启电脑

b)手工的把僵尸进程的父进程kill掉，僵尸进程就会自动消失；

c)处理`SIGCHLD`信号：一个进程被终止或者停止时，这个信号会被发送给父进程；所以，对于源码中有`fork()`行为的进程，我们应该拦截并处理`SIGCHLD`信号；

```c
pid_t waitpid(pid_t pid, int *status, int options);
```

### 1.2 fork()函数进一步认识
fork()产生新进程的速度非常快，==fork()产生的新进程并不复制原进程的内存空间，而是和原进程（父进程)一起共享一个内存空间，但这个内存空间的特性是“写时复制==，也就是说：原来的进程和fork()出来的子进程可以同时、自由的读取内存，但如果子进程（父进程）对内存进行修改的话，那么这个内存就会复制一份给该进程单独使用，以免影响到共享这个内存空间的其他进程使用；

### 1.3 完善一下fork()代码
fork()会返回两次：父进程中返回一次，子进程中返回一次,而且，fork()在父进程中返回的值和在子进程中返回的值是不同的，子进程的fork()返回值是0；父进程的fork()返回值是新建立的子进程的ID，因为全局量`g_mygbltest`的值发生改变，导致主子进程内存被单独的分开，所以每个的`g_mygbltest`值也不同；

**一个和fork()执行有关的逻辑判断（短路求值）**

```c
((fork() && fork()) || (fork() && fork())) // 总共创建 7 个进程
```

### 1.4 fork()失败的可能性
a)系统中进程太多，缺省情况，最大的pid：32767

b)每个用户有个允许开启的进程总数：7788



## 二、守护进程详解

### 2.1 普通进程运行观察
 `ps -eo pid,ppid,sid,tty,pgrp,comm,stat,cmd | grep -E 'bash|PID|nginx'`
a)进程有对应的终端，如果终端退出，那么对应的进程也就消失了（==它的父进程是一个bash进程==）
b)终端被占用，输入各种命令这个终端都没有反应；

### 2.2 守护进程基本概念
**守护进程**：一种长期运行的进程，这种进程在后台运行，==并且不跟任何的控制终端关联==；

**基本特点：**
 a)生存期长[不是必须，但一般应该这样做]，一般是操作系统启动的时候他就启动，操作系统关闭的时候他才关闭
 b)守护进程跟终端无关联，也就是说他们没有控制终端，所以你控制终端退出，也不会导致守护进程退出
 c)守护进程是在后台运行,不会占着终端，终端可以执行其他命令

linux操作系统本身是有很多的守护进程在默默的运行，维持着系统的日常活动，大概30-50个

```bash
a)ppid = 0：内核进程，跟随系统启动而启动，生命周期贯穿整个系统；
b)cmd 列名字带[]，内核级守护进程；
c)init：也是系统守护进程,它负责启动各运行层次特定的系统服务；所以很多进程的PPID是init。而且这个init也负责收养孤儿进程；
d)cmd 列中名字不带[]的普通守护进程（用户级守护进程）

共同点总结：
a)大多数守护进程都是以超级用户特权运行的；
b)守护进程没有控制终端，TT列显示?
  内核守护进程以无控制终端方式启动
  普通守护进程可能是守护进程调用了setsid的结果（无控制端）；
```

### 2.3 守护进程编写规则
(1)调用`umask(0) // 防止干扰文件权限`
 `umask`是个函数，用来限制（屏蔽）一些文件权限的。
(2)`fork()`一个子进程(脱离终端)出来,然后父进程退出( 把终端空出来，不让终端卡住)；
` fork()`的目的是想成功调用`setsid()`来建立新会话，目的是让子进程有单独的`sid`；而且子进程也成为了一个新进程组的组长进程；同时，子进程不关联任何终端了

**--------------讲解一些概念**
**（3.1）文件描述符：正数，用来标识一个文件。**
   当你打开一个存在的文件或者创建一个新文件，操作系统都会返回这个文件描述符（其实就是代表这个文件的），后续对这个文件的操作的一些函数，都会用到这个文件描述符作为参数；

linux中三个特殊的文件描述符，数字分别为0,1,2 
       0:标准输入【键盘】，对应的符号常量叫`STDIN_FILENO`
       1:标准输出【屏幕】，对应的符号常量叫`STDOUT_FILENO`
	   2:标准错误【屏幕】，对应的符号常量叫`STDERR_FILENO `

类Unix操作系统，默认从STDIN_FILENO读数据，向STDOUT_FILENO来写数据，向STDERR_FILENO来写错误；
类Unix操作系统有个说法：==一切皆文件==,所以它把标准输入，标准输出，标准错误都看成文件。
与其说 把   标准输入，标准输出，标准错误 都看成文件   到不如说
          **像看待文件一样看待    标准输入，标准输出，标准错误
		  像操作文件一样操作    标准输入，标准输出，标准错误**

同时，程序一旦运行起来，这三个文件描述符0,1,2会被自动打开(自动指向对应的设备)；

文件描述符虽然是数字，但是，如果我们把文件描述符直接理解成指针（指针里边保存的是地址——地址说白了也是个数字）；
`write(STDOUT_FILENO,"aaaabbb",6);`

**（3.2）输入输出重定向**
输出重定向：我标准输出文件描述符，不指向屏幕了，假如我指向（重定向）一个文件，在命令行中用 `>`即可；

输入重定向  `<`

**（3.3）空设备（黑洞）**
   `/dev/null  `    ：是一个特殊的设备文件，它丢弃一切写入其中的数据（像黑洞一样）；

守护进程是在后台运行，它不应该从键盘上接收任何东西，也不应该把输出结果打印到屏幕或者终端上来
所以，一般按照江湖规矩，我们要把守护进程的 标准输入，标准输出重定向到空设备（黑洞），从而确保守护进程不从键盘接收任何东西，也不把输出结果打印到屏幕；

```c
int fd;
fd = open("/dev/null",O_RDWR) ; //打开空设备

dup2(fd,STDIN_FILENO); //复制文件描述符  ，类似指针赋值,把第一个参数指向的内容赋给了第二个参数；
dup2(fd,STDOUT_FILENO);
if(fd > STDERR_FILENO) {
    close(fd); //等价于fd = null，关闭文件描述符，防止占用系统资源
}
```

**（3.4）实现范例**

守护进程可以用命令启动，如果想开机启动，则需要借助系统初始化脚本来启动

```c
/*-------------------------------------------------------------/
 * @file   04_daemon.c
 * @author DuYong
 * @email  gz_duyong@163.com 
 * @date   2021年01月25日 星期一 15时25分20秒
 *------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>

int my_daemon() {
	int fd;

	// fork子进程，设置新会话，关闭父进程
	switch(fork()) {
		case -1:
			return -1;
		case 0:
			break;
		default:
			exit(0);
	}

	if(setsid() == -1) {
		return -1;
	}

	// 重定向标准输入，输出
	umask(0);
	fd = open("/dev/null", O_RDWR);
	if(dup2(fd, STDIN_FILENO) == -1) {
		return -1;
	}

	if(dup2(fd, STDOUT_FILENO) == -1) {
		return -1;
	}

	if(fd > STDERR_FILENO) {
		close(fd);
	}

	return 0;
}

int main() {
	if(my_daemon() != -1) {
		while(1) {
			sleep(1);
			printf("I am a daemom process.\n");
		}
	}

	return 0;
}
```



### 2.4 守护进程不会收到的信号

4.1）`SIGHUP`信号
守护进程不会收到来自内核的  `SIGHUP` 信号； 潜台词就是如果守护进程收到了 `SIGHUP`信号，那么肯定是另外的进程发给你的；==很多守护进程把这个信号作为通知信号，表示配置文件已经发生改动，守护进程应该重新读入其配置文件==；

4.2）`SIGINT、SIGWINCH`信号
守护进程不会收到来自内核的  `SIGINT（ctrl+C),SIGWINCH(终端窗口大小改变) `信号；

### 2.5 守护进程和后台进程的区别
(1)守护进程和终端不挂钩；后台进程能往终端上输出东西；
(2)关闭终端时守护进程不受影响，后台进程会随着终端的退出而退出； 	  	   	  