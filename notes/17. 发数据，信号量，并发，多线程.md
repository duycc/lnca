# 17. 发数据，信号量，并发，多线程

### 1.1 发送数据思想
把要发送的数据放到一个队列中`msgSend`，然后专门创建一个线程`ServerSendQueueThread`来统一负责数据发送

### 1.2 发送数据代码
**信号量：也是一种同步机制**

互斥量：==线程==之间同步
信号量：提供==进程==之间的同步，也能提供==线程==之间的同步

用之前调用`sem_init()`初始化一下，信号量的初始值给0
用完后`sem_destroy()`释放信号量
`sem_wait()`：测试指定信号量的值，如果该值>0，那么将该值-1然后该函数立即返回，如果该值等于0，那么该线程将投入睡眠中，一直到该值>0，这个时候那么将该值-1然后该函数立即返回
`semd_post()`：能够将指定信号量值+1，即便当前没有其他线程在等待该信号量值也没关系

**数据发送线程 `ServerSendQueueThread` **

**可写通知到达后数据的继续发送**
`ngx_write_request_handler(); `

**发送数据的简单测试**

发送缓冲区大概10-几10K，如何把发送缓冲区撑满

（1）每次服务器给客户端发送65K左右的数据，发送到第20次才出现服务器的发送缓冲区满，这时客户端收了一个包(65K)，此时执行了`ngx_write_request_handler()`

（2）继续发包，连续成功发送了16次，才又出现发送缓冲区满；我客户端再收包，结果连续收了16次包，服务器才又出现`ngx_write_request_handler()`函数被成功执行，这表示客户端连续收了16次包，服务器的发送缓冲区才倒出地方来

（3）此后，大概服务器能够连续发送16次才再出现发送缓冲区满，客户端连续收16次，服务器端才出现`ngx_write_request_handler()`被执行

**测试结论：**
（1）`ngx_write_request_handler()`，逻辑正确，能够通过此函数把剩余的未成功发送的数据发送出去

（2）LT模式下，发送数据采用的改进方案是非常有效的，在很大程度上提高了效率

（3）发送缓冲区大概10-几10K，但是实际测试的时候，成功的发送出去了1000多k数据才报告发送缓冲区满，当发送端调用send()发送数据时，操作系统底层已经把数据发送到了 该连接的接收端的接收缓存，这个接收缓存大概有几百K，==千万不要认为发送缓冲区只有几十K，send()几十k就能把发送缓冲区填满==

（4）只要对方不接收数据，发送方的发送缓冲区总有满的时候，当发送缓冲满的时候，发送数据就会使用`ngx_write_request_handler()`来执行

### 1.3 发送数据后续处理代码

