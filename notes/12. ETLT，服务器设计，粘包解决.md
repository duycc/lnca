# 12. ET/LT，服务器设计，粘包解决

## 一、ET，LT模式深入分析

LT：水平触发/低速模式，这个事件没处理完，就会被一直触发
ET：边缘触发/告诉模式，这个事件通知只会出现一次

普遍认为 ET 比 LT 效率高一些，但是 ET 编程难度比 LT 大一些
==ET 模式下，如果没有数据可接收，则 recv 会返回 -1==

**思考：**为什么ET模式事件只触发一次[事件被扔到双向链表中一次，被`epoll_wait`取出后就销毁]，LT模式事件会触发多次呢？[事件如果没有处理完，那么事件会被多次往双向链表中扔]

**如何选择ET，还是LT：**

如果收发数据包有固定格式,建议采取LT，编程简单，清晰，写好了效率不见得低，如果收发数据包没有固定格式，可以考虑采用ET模式

## 二、服务器设计

### 2.1 服务器设计原则总述
此项目：通用的服务框架，将来稍加改造甚至不用改造就可以把它直接应用在很多的具体开发工作中

### 2.2 收发包格式问题提出
### 2.3 TCP粘包、缺包
tcp粘包问题：client发送`abc,def,hij`，三个数据包发出去

**a) 客户端粘包现象**

客户端因为有一个Nagle优化算法

```
send("abc"); 
send("def");
send("hij");
```


因为 Nagle 算法存在的，这三个数据包被Nagle优化算法直接合并一个数据包发送出去，这就属于客户端粘包。关闭Nagle优化算法，那么调用几次`send()`就发送出去几个包，那客户端的粘包问题就解决了

**b) 服务器端粘包现象**

==不管客户端是否粘包，服务器端都存在粘包的问题==

服务器端两次 recv 之间可能间隔100毫秒，那可能在这100毫秒内，客户端这三个包都到了，这三个包都被保存到了服务器端的针对该TCP连接收数据缓冲中`"abcdefhij"`，再次recv，就可能拿到了全部的`"abcdefhij"`，这就叫服务器端的粘包

```c
send("abc......."); // 8000字节，这个可能被操作系统拆成6个包发送出去了
// 网络可能出现延迟或者阻塞，
// 服务器端分多次接受数据
recv() = "ab"
recv() = "c..."
recv() = "........."
recv() = ".....de" // [缺包]
```

### 2.4 TCP粘包、缺包解决
==粘包，要解决的就是把这几个包拆出来，一个是一个==

**严谨性：**`abc$def$hij` ,加特殊标记法，很多服务器程序员不考虑恶意数据包，服务器程序员不能假设收到的数据包都是善意的，合理的，构造畸形数据包`abc#def-hij`

**如何解决拆包问题：**给收发的数据包定义一个统一的格式

**[规则]** c/s都按照这个格式收发数据，就能够解决粘包问题
包格式： 包头+包体 的格式，其中包头是固定长度【10字节】,在包头中，有一个成员变量会记录整个包【包头+包体】的长度，这样的话，先收包头，从包头中，就知道了整个包的长度，然后用整个包的长度 - 10个字节 = 包体的长度。再收 “包体的长度”这么多的字节，收满了包体的长度字节数，则认为，一个完整的数据包【包头+包体】接受完成

```
收包总结：
（1）先收固定长度包头10字节；
（2）收满后，根据包头中的内容，计算出包体的长度：整个长度-10
（3）再收包体长度这么多的数据，收完了，一个包就完整了；
这样就可以认为受到了一个完整的数据包，从而解决了粘包的问题
```

## 三、收包解包实战

### 3.1 收包分析及包头结构定义
发包：采用包头+包体，其中包头中记录着整个包【包头+包体】的长度，包头，就是一个结构

a) 一个包的长度不能超过 30000 个字节，必须要有最大值，确保服务器不会处于非常危险的境地

b) 定义包头结构：`COMM_PKG_HEADER`

c) ==结构字节对齐问题==，为了防止出现字节问题，所有在网络上传输的这种包结构，必须都采用1字节对齐方式

### 3.2 收包状态宏定义
收包问题：粘包，缺包
收包思路：先收包头 -> 根据包头中的内容确定包体长度并收包体，收包状态（状态机）
定义几种收包的状态, 4种：0,1,2,3

### 3.3 收包实战代码
```c++
ngx_wait_request_handler()
// 同时设置好各种收包的状态：
c->curStat = _PKG_HD_INIT;   
c->precvbuf = c->dataHeadInfo; 
c->irecvlen = sizeof(COMM_PKG_HEADER); 
```

客户端连入到服务器后，要主动地给服务器先发送数据包，服务器要主动收客户端的数据包，服务器按照包头 + 包体的格式来收包

引入一个消息头`STRUC_MSG_HEADER`，用来记录一些额外信息
服务器收包时收到： 包头+包体  ，再额外附加一个消息头：`消息头 + 包头 + 包体`

再介绍一个分配和释放内存类`CMemory`

内存池：对于提高程序运行效率帮助有限，new非常快，内存池主要功能就是频繁的分配小块内存时，内存池可以节省额外内存开销但代码会更加复杂

### 3.4 遗留问题处理
```cpp
inMsgRecvQueue(char* buf);
tmpoutMsgRecvQueue();
clearMsgRecvQueue();
```

### 3.5 测试服务器收包
验证`ngx_wait_request_handler()`函数是否正常工作,准备写一个客户端程序

==觉悟：服务器主程序员，所以服务器端有必要自己书写一个客户端测试程序，先自己确保程序没有问题，再进行联合调试==

