# 18. 心跳包代码

### 1.1 前期学习总结
**核心架构浓缩总结实现的功能：**

* 服务器按照包头包体格式正确的接收客户端发送过来的数据包
* 根据收到的包的不同来执行不同的业务处理逻辑
* 把业务处理产生的结果数据包返回客户端

**用到的主要技术**

* epoll高并发通讯技术
* 线程池技术来处理业务逻辑
* 线程之间的同步技术包括互斥量、信号量
* 其他技术：信号，日志打印，fork()子进程，守护进程

**借鉴官方nginx的精华代码：**

1. master进程，多个worker子进程
2. 借鉴了epoll的一些实现代码，官方nginx用的ET，本项目中用的是水平触发模式LT
3. 借鉴了接收数据包，以及发送数据包的核心代码

**没有借鉴官方nginx的地方：**

1. 比如epoll技术中采用LT模式来实现网络数据的接收和发送

2. 自己写一套线程池来处理业务逻辑，调用适当的业务逻辑处理函数，直至处理完毕把数据发送回客户端

3. 连接池中连接的延迟回收，以及专门处理数据发送的发送线程


### 1.2 心跳包概念
**什么叫心跳包以及如何使用？**

心跳包就是一个普通的数据包，一般每隔几十秒（10秒-60秒之间），由客户端主动发送给服务器，服务器收到之后，一般会给客户端返回一个心跳包

三路握手，tcp连接建立之后，才存在发送心跳包的问题，如果client不给server发心跳包，服务器可能会在90秒或者100秒内，主动关闭该客户端的socket连接

作为一个良好的客户端程序，如果发送了心跳包给服务器，但是在90或者100秒之内，客户端没有收到服务器回应的心跳包，那么客户端就应该主动关闭与服务器端的连接，如果业务需要重连，客户端程序在关闭这个连接后还要重新主动再次尝试连接服务器，客户端程序也有义务提示使用者客户端与服务器的连接已经断开

**为什么要使用心跳包？**

常规客户端关闭，服务器能感知到，有一种特殊情况，连接断开客户端和服务端都感知不到，即==拔掉网线==导致的连接断开

tcp的`keep-alive`机制：检测时间不好控制

为了应对拔网线，导致双方不知道是否断开了tcp连接这种情况，引入心跳包机制

**心跳包作用：**

* 超时没有发送来心跳包，那么就会将对端的`socket`连接`close`掉，回收资源
* 检测网络延迟等

### 1.3 心跳包代码
**接收心跳包与返回结果**

规定消息代码为0，一般心跳包也不需要包体，只有包头就可以

**处理不发送心跳包的客户端**

30秒，超过`30 * 3 + 10 = 100`秒，仍旧没收到心跳包，那么服务器端就把tcp断开

增加配置`Sock_WaitTimeEnable，Sock_MaxWaitTime`

修改`ReadConf()`函数读取配置信息

`AddToTimerQueue()` :把一个连接的信息加入到时间队列中来；该函数由`ngx_event_accept()`函数在连接成功连入时调用

新线程处理时间队列中的数据：

`ServerTimerQueueMonitorThread();`
`GetOverTimeTimer();RemoveFirstTimer();procPingTimeOutChecking();zdClosesocketProc()`
`inRecyConnectQueue()；ServerRecyConnectionThread();clearAllFromTimerQueue()`

**测试代码的书写**

