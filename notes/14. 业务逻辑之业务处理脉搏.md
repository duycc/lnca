# 14. 业务逻辑之业务处理脉搏

### 1.1 线程池代码调整及补充说明
支撑线程池的运作主要靠两个函数：

```cpp
pthread_cond_signal(&m_pthreadCond) 				// 触发
pthread_cond_wait(&m_pthreadCond, &m_pthreadMutex);	// 等待
```

==条件变量，是线程可用的另一种同步机制，条件变量给多个线程提供了一个会合的场所,条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生==

a) 条件本身`while ( (pThreadPoolObj->m_MsgRecvQueue.size() == 0) && m_shutdown == false)` 是由互斥量保护的，线程在改变条件状态之前必须首先锁住互斥量，其他线程在获取到互斥量之前不会觉察到这种改变，因为互斥量必须在锁定以后才能计算条件

b) 传递给`pthread_cond_wait`的互斥量`m_pthreadMutex`对条件` while ( (pThreadPoolObj->m_MsgRecvQueue.size() == 0) && m_shutdown == false)`进行保护的，调用者把锁住的互斥量传递给函数`pthread_cond_wait`，函数然后自动把调用线程放在等待条件的线程列表上，对互斥量解锁，这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化`pthread_cond_wait`返回时，互斥量再次被锁定

### 1.2 线程池实现具体业务
**一个简单的crc32校验算法介绍**

`CCRC32`类：主要目的是对收发的数据包进行一个简单的校验，以确保数据包中的内容没有被篡改过
`Get_CRC()`：给一段buffer，也就是一段内存，然后给出这段内存长度，该函数计算出一个数字(CRC32值)

**引入新的CSocket子类**

真正项目中要把CSocekt类当成父类使用，具体业务逻辑代码应该放在CSocket的子类中，`threadRecvProcFunc()`收到消息之后的处理函数

**设计模式题外话**

有很多人善于乐于抽象，把一个一个小功能封装成一个一个类，往设计模式上套进行所谓的面向对象程序设计，每个人有每个人写代码的喜好

a) 类太多，别人理解起来就非常困难，另外类太多，对程序效率影响很大
b) 几十万，上百万上代码，里边很多部件需要灵活调整，==经常变动，不稳定的部分，才需要抽象出来，用虚函数，通过设计模式来灵活解决，不要乱用设计模式，不要乱封装==

**消息的具体设计**

为了能够根据客户端发送过来的消息代码迅速定位到要执行的函数，把客户端发送过来的消息代码直接当做一个数组的下标来用

服务器业务逻辑，主要集中在三个文件中：`ngx_logiccomm.h，ngx_c_slogic.cxx，ngx_c_slogic.h`

### 1.3 threadRecvProcFunc()函数讲解

### 1.4 整体测试工作的开展
c/s配合工作，配合指定通讯协议，协议的制定一般是服务器程序员来主导

(1) 确定通讯格式是包头+包体，包头固定多少个字节，这种规则是服务器端来制定并在开发一个项目之前，要明确的和客户端交代好，要求客户端给服务器发送数据包时严格遵循这种格式
(2) 注册，登录，都属于具体的业务逻辑命令，这种命令一般都是由服务器牵头来制定

**不做背锅侠**

服务器开发难度往往比客户端大很多，责任也重很多，要求也高得多。讲清楚：服务器端要负责通讯协议的制定工作，以免跟客户端推诿扯皮，服务器有能力站在客户端的角度去制定各种通讯协议，商量，共同指定协议和数据结构，共同制定协议

**客户端测试代码的调整**

服务器端有责任把crc32算法给到客户端



```todo
inMsgRecvQueueAndsignal() 函数，线程池代码调整
```

